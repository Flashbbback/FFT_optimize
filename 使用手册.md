# AVX加速FFT核心模块使用手册
## 一、项目背景介绍
本模块是专为信号处理场景设计的**AVX指令集加速FFT核心组件**，尽可能加快FFT计算过程。模块包含两类核心实现：AVX单精度浮点版和AVX定点版（Q15格式），通过“小尺寸旋转因子硬编码+中大型因子实时重排”优化，彻底移除冗余存储，兼顾计算速度、内存占用与精度平衡。

适用场景：频谱分析、通信系统、实时信号处理等需高效FFT运算的场景，支持从256点到16384点（2⁸~2¹⁴）的2次幂尺寸FFT计算，适配支持AVX指令集的CPU硬件。


## 二、核心功能说明
| 功能类型         | 具体描述                                                                 |
|------------------|--------------------------------------------------------------------------|
| AVX浮点版FFT     | 基于AVX 256位向量指令集，并行处理8个单精度浮点数，无冗余旋转因子存储，大尺寸通过实时重排表优化访问 |
| AVX定点版FFT     | Q15格式（1位符号位+15位小数位）量化计算，小尺寸（M=2/4/8）旋转因子硬编码，中大型（M≥16）实时重排，内存占用极低 |
| 上下文资源管理   | 提供上下文初始化（预计算位反转索引、重排旋转因子表）与资源释放接口，支持多尺寸FFT复用 |



## 三、关键算法与实现解释
### 1. 核心FFT算法框架
所有版本均基于**基-2蝶形运算**优化，通过分治思想将N点FFT拆解为多个小尺寸子FFT，核心步骤：
1. 位反转重排：对输入序列按二进制位反转排序，确保蝶形运算时数据连续访问，提升缓存命中率；
2. 多阶段蝶形运算：按层级（s=1至log₂N）处理，每阶段处理M=2ˢ点子FFT，通过旋转因子合并子结果；
3. AVX并行加速：利用256位向量寄存器（`__m256`/`__m256i`）并行计算8个浮点/16个定点数据，提升吞吐量。


### 2. 定点版精度控制
- 量化范围：Q15格式支持[-1.0, 1.0)浮点范围映射，通过饱和截断避免溢出（超出`INT16_MAX`/`INT16_MIN`时强制钳位）；
- 乘法优化：使用`_mm256_mulhrs_epi16`指令实现带舍入的16位整数乘法，减少量化误差累积。


### 3. 旋转因子重排
对于预计算的旋转因子，为了保证在FFT计算过程中能够连续的读取旋转因子，将计算好的旋转因子表根据计算方式进行了重排，使得浮点版本中M>=8以及定点版M>=16的数据能够直接读取连续的8个旋转因子，大大提升了运行速度，在我们的测试中，速度提升近一倍。


## 四、上手使用指南
### 1. 环境要求
| 类别         | 具体要求                                                                 |
|--------------|--------------------------------------------------------------------------|
| 操作系统     | Windows（依赖`_aligned_malloc`/`_aligned_free`）                         |
| 编译器       | 支持AVX指令集的C编译器（MSVC、GCC 4.7+、Clang 3.1+），需启用AVX编译选项 |
| 硬件         | 支持AVX指令集的CPU（Intel Sandy Bridge及以上、AMD Bulldozer及以上）       |
| 数据要求     | 输入/输出数组需32字节对齐（推荐用`_aligned_malloc`分配），FFT尺寸为2的幂 |

### 2. 交付Package结构
```
AVX_FFT_Module/
├── src/
│   ├── FFT.c         // 核心实现（上下文管理、AVX浮点/定点FFT）
│   └── FFT.h         // 接口声明、宏定义、数据结构
├── example/
│   └── demo.c        // 调用示例（浮点+定点版完整使用流程）
├── Makefile          // 编译脚本（支持GCC/MSVC）
└── README.md         // 本使用手册
```

### 3. 编译步骤
#### （1）GCC编译
```bash
# 启用AVX指令集，生成可执行文件
gcc src/FFT.c example/demo.c -o avx_fft_demo -mavx -O2
```

#### （2）MSVC编译（Visual Studio命令行）
```cmd
cl src/FFT.c example/demo.c /Fe:avx_fft_demo.exe /arch:AVX /O2
```

### 4. 核心接口说明
#### （1）上下文初始化
```c
FFTContext* trig_table(int max_size);
```
- 功能：预计算位反转索引、中大型旋转因子重排表（M≥16）；
- 参数：`max_size`为支持的最大FFT尺寸（必须为2的幂，如1024、2048）；
- 返回值：成功返回上下文指针，失败返回`NULL`（内存分配失败）。

#### （2）上下文资源释放
```c
void free_trig_table(FFTContext* ctx);
```
- 功能：释放上下文占用的所有资源（重排表、位反转索引等），避免内存泄漏；
- 参数：`ctx`为已初始化的上下文指针。

#### （3）AVX浮点版FFT
```c
void fft_AVX(float real[], float imag[], int N, FFTContext* ctx);
```
- 功能：对输入的浮点信号执行FFT变换，结果覆盖原输入数组；
- 参数：
  - `real`：输入/输出实部数组（32字节对齐，长度N）；
  - `imag`：输入/输出虚部数组（32字节对齐，长度N）；
  - `N`：FFT尺寸（2的幂，且≤`max_size`）；
  - `ctx`：已初始化的上下文指针。

#### （4）AVX定点版FFT
```c
void fft_AVX_fixedP(int16_t real[], int16_t imag[], int N, FFTContext* ctx);
```
- 功能：对Q15格式定点信号执行FFT变换，结果覆盖原输入数组；
- 参数：
  - `real`：输入/输出实部数组（32字节对齐，长度N，Q15格式）；
  - `imag`：输入/输出虚部数组（32字节对齐，长度N，Q15格式）；
  - `N`：FFT尺寸（2的幂，且≤`max_size`）；
  - `ctx`：已初始化的上下文指针。

### 5. 完整调用示例（demo.c）
```c
#include "FFT.h"
#include <stdlib.h>
#include <stdio.h>

int main() {
    // 1. 配置参数（FFT尺寸为1024，2的幂）
    const int N = 1024;
    FFTContext* ctx = trig_table(N);
    if (!ctx) {
        printf("上下文初始化失败！\n");
        return -1;
    }

    // 2. 分配32字节对齐的输入/输出数组
    // 浮点版数组
    float* float_real = (float*)_aligned_malloc(N * sizeof(float), 32);
    float* float_imag = (float*)_aligned_malloc(N * sizeof(float), 32);
    // 定点版数组（Q15格式）
    int16_t* q15_real = (int16_t*)_aligned_malloc(N * sizeof(int16_t), 32);
    int16_t* q15_imag = (int16_t*)_aligned_malloc(N * sizeof(int16_t), 32);

    // 3. 填充输入信号（以单频正弦信号为例）
    for (int i = 0; i < N; i++) {
        // 浮点信号：sin(2π*10*i/N)，频率10Hz
        float sig_float = sinf(2 * M_PI * 10 * i / N);
        float_real[i] = sig_float;
        float_imag[i] = 0.0f;

        // 定点信号：转换为Q15格式
        q15_real[i] = FLOAT_TO_Q15(sig_float);
        q15_imag[i] = 0; // 虚部为0
    }

    // 4. 调用FFT计算
    fft_AVX(float_real, float_imag, N, ctx);         // 浮点版
    fft_AVX_fixedP(q15_real, q15_imag, N, ctx);      // 定点版

    // 5. 处理结果（示例：打印前10个点的实部/虚部）
    printf("=== 浮点版FFT结果（前10点）===\n");
    for (int i = 0; i < 10; i++) {
        printf("第%d点：实部=%.6f，虚部=%.6f\n", i, float_real[i], float_imag[i]);
    }

    printf("\n=== 定点版FFT结果（前10点，Q15转浮点）===\n");
    for (int i = 0; i < 10; i++) {
        printf("第%d点：实部=%.6f，虚部=%.6f\n", 
               i, Q15_TO_FLOAT(q15_real[i]), Q15_TO_FLOAT(q15_imag[i]));
    }

    // 6. 释放资源
    _aligned_free(float_real);
    _aligned_free(float_imag);
    _aligned_free(q15_real);
    _aligned_free(q15_imag);
    free_trig_table(ctx);

    return 0;
}
```


## 五、交付说明
### 1. 交付物清单
- 核心代码：`FFT.h`（接口声明）、`FFT.c`（实现）；
- 示例代码：`demo.c`（完整调用流程）；
- 编译脚本：`Makefile`（兼容GCC/MSVC）；
- 文档：本使用手册（`README.md`）。

### 2. 集成说明
- 模块无第三方依赖，仅需包含`FFT.h`和`FFT.c`到目标项目；
- 编译时需启用AVX选项（GCC：`-mavx`，MSVC：`/arch:AVX`）和优化选项（`-O2`/`/O2`）；
- 使用者需保证输入数组32字节对齐，建议使用`_aligned_malloc`分配内存。

### 3. 注意事项
- FFT尺寸必须为2的幂，否则会导致计算错误（建议在`trig_table`中添加尺寸校验，本模块默认用户输入合法）；
- 定点版输入信号幅值需≤1.0，否则量化时会溢出钳位，影响精度；
- 上下文指针需在所有FFT计算完成后释放，避免野指针访问。